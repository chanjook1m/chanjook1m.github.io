{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/WIL",
    "result": {"pageContext":{"currentCategory":"WIL","categories":["All","WIL","PS","블로그"],"edges":[{"node":{"id":"b6ab9706-e1d3-5124-b491-b0ceaf59f00d","excerpt":"시작 읽기 전에 알면 좋은 내용: 블록 요소들은 위에서 아래로 배치되고 inline은 왼쪽에서 오른쪽으로 배치된다. 이러한 동작을 normal flow라고 한다 block_inline block formatting context 에서는 자식 요소들이 normal flow 형식으로 배치된다 html 태그는 가장 처음으로 생성되는 block formatting context이다 요약 block formatting context는 layout에 영향을 주는 성질을 가지고 있지만 보통 float 요소의 위치를 잡을때나 margin collapsing을 방지할때 사용한다고 한다 Contain internal floats 자식 요소 중 float 요소가 있을때 해당 요소를 다른 자식 요소의 height와 동일하게 맞출때 (float 자식 요소가 있을때 동일한 block formatting context에 자식 요소들을 넣을때) bfc1; Exclude external floats 형제 요소 …","fields":{"slug":"/CSS - BFC(block formatting context)/"},"frontmatter":{"categories":"WIL","title":"CSS - BFC(Block formatting context)","date":"September 18, 2022"}},"next":{"fields":{"slug":"/js - BrickBreak/"}},"previous":null},{"node":{"id":"5173b189-3695-5358-94e5-3f10296f4649","excerpt":"시작 기본 로직 canvas를 사용해 brick, ball, paddle을 도형으로 그려준다 requestAnimationFrame 함수를 사용해 update와 draw함수를 무한하게 반복적으로 실행하도록 한다 BrickBreak 클래스의 인스턴스를 생성해 init 함수로 게임을 실행한다 requestAnimationFrame 장점: tab이 비활성화 되면 중지, 60프레임으로 동작, 브라우저가 프레임 생성 시간에 맞춰서 애니메이션 코드를 실행 시켜 애니메이션이 부드럽게 동작함 접근성과 관련해 100% 커버리지가 아니라 polyfill 사용하는 것을 추천 (https://gist.github.com/paulirish/1579671) canvas beginPath = 선을 그릴때 시작하는 함수 closePath = 선을 그릴때닫아서 시작점과 잇는 함수 추가한 내용 fontFamily의 크기를 일일히 입력 해주어야하고 canvas에서 한번에 바꾸는 것이 안되어 font의 값들을 배열로…","fields":{"slug":"/js - BrickBreak/"},"frontmatter":{"categories":"WIL","title":"js project - brick break","date":"September 18, 2022"}},"next":{"fields":{"slug":"/Functional Programming - immutability/"}},"previous":{"fields":{"slug":"/CSS - BFC(block formatting context)/"}}},{"node":{"id":"659b0829-6156-57d2-9216-efc01be5f828","excerpt":"시작 읽기 전에 알면 좋은 내용: immutability는 함수형 프로그래밍의 핵심 개념중 하나로 pure function이 가지고 있는 특징 중 하나이다 side effect란 local environment 가 아닌 다른 environment의 vaiable의 상태(값)를 변경 하는 것을 말한다. 예를 들어 change라는 함수가 global variable a의 값을 변경한다면 side effect가 발생한 것이다 immutability개념을 사용하면 side effect를 방지할 수 있다 요약 immutability란 객체가 생성된 이 후 해당 객체의 상태를 변경할 수 없다는 것을 의미한다. 조금 더 구체적으로 말하자면 메모리의 특정한 주소에 할당된 객체 값이 변경되면 안된다는 것이다 간단하게 말하면 immutable은 메모리 주소에 저장된 내용을 변경할 수 없고 mutable은 메모리 주소에 저장된 내용을 변경할 수 있다는 개념이다 immutable value immuta…","fields":{"slug":"/Functional Programming - immutability/"},"frontmatter":{"categories":"WIL","title":"Functional Programming - immutability","date":"September 10, 2022"}},"next":{"fields":{"slug":"/js - progress bar/"}},"previous":{"fields":{"slug":"/js - BrickBreak/"}}},{"node":{"id":"a035bfb0-cd0e-551c-b054-8eab30b792b1","excerpt":"시작 정리 박스 모델 기준으로 자바스크립트에서 얻어올 수 있는 값 해당 박스의 border 바깥 쪽은 offsetTop, offsetLeft border 사이는 clientTop, clientLeft 안에 content는 clientWidth, clientHeight border와 content를 합한 것은 offsetWidth, offsetHeight 보여지는 박스가 아닌 content의 전체 길이는 scrollHeight 현재 스크롤바의 위치는 scrollTop values throttle & debounce 이벤트나 요청의 처리 횟수를 컨트롤할때 사용 되는 개념이다 요 사이트에서 마우스 이동 이벤트를 사용한 throttle, debounce 타임 라인을 보면 이해하는데 약간 도움이 되는 것 같다 debounce 들어온 동일한 요청을 하나로 모은 후 마지막 요청만 특정 시간이 지나고나면 실행한다. 여러 요청이 발생 하는데 요청이 다 끝나고 난 후 특정 시간이 지나고 처리할때 사…","fields":{"slug":"/js - progress bar/"},"frontmatter":{"categories":"WIL","title":"js project - progress bar","date":"September 10, 2022"}},"next":{"fields":{"slug":"/Leetcode-114/"}},"previous":{"fields":{"slug":"/Functional Programming - immutability/"}}},{"node":{"id":"366813c1-f81e-5a5d-a6e3-614d868abea6","excerpt":"시작 읽기 전에 알면 좋은 내용: 클라이언트 서버 모델이란? 클라이언트 서버 모델은 서버가 데이터를 가지고 있고 클라이언트에서 데이터를 요청하면 서버에서 데이터를 넘겨 주는 방식의 모델이다 실제로는 통신할때 클라이언트와 서버 사이에 라우터, 모델과 같은 여러 컴퓨터들이 있지만 요런 것들은 network, transport layer에서 처리되고 HTTP는 application layer protocol이기 때문에 서버, 클라이언트 사이의 request와 response에 대해서만 알면된다 server-client 프로토콜이란? 프로토콜은 두 컴퓨터가 소통할떄 어떻게 소통할지 정해놓은 규칙이다. 예를들어 데이터를 어떤 형식으로 보낼 것인지 어떤 순서대로 보낼 것인지 등 요약 서버/클라이언트 모델 기반 프로토콜 connectionless & stateless request, response 구조 http request 상태 코드 http 특징 서버/클라이언트 모델 기반 프로토콜 어떤 …","fields":{"slug":"/http-basic/"},"frontmatter":{"categories":"WIL","title":"http basic","date":"September 02, 2022"}},"next":{"fields":{"slug":"/js-single-thread-non-blocking/"}},"previous":{"fields":{"slug":"/Leetcode-116/"}}},{"node":{"id":"4eceb791-fe8e-5cf2-beeb-bc99c2a13646","excerpt":"시작 읽기 전에 알면 좋은 내용: 프로세스는 메모리에 올라가 실행되는 상태에 있는 프로그램이다 blocking/non-blocking은 호출되는 프로세스가 제어권을 호출하자마자 돌려주는지 아니면 할일을 처리하고 돌려주는지에 대한 것이다 요약 javvascript engine는 single threaded이고 javascript runtime은 multi threaded라 non blocking이 가능하다 자바스크립트는 싱글 스레드, non-blocking 언어이다 위 문장의 정확한 뜻은 자바스크립트 엔진이 싱글 스레드, 자바스크립트 런타임이 non-blocking 이기 때문에 자바스크립트는 싱글 스레드 + non-blocking 두 가지 특징을 모두 갖는다는 의미이다  자바스크립트 엔진 자바스크립트 엔진은 1개의 call stack을 가지고 있기 때문에 한번에 하나의 작업만 처리 가능하다 (=싱글 스레드) 자바스크립트 런타임 자바스크립트 런타임은 실제로 자바스크립트가 실행되는 환경…","fields":{"slug":"/js-single-thread-non-blocking/"},"frontmatter":{"categories":"WIL","title":"javascript - single thread + non-blocking","date":"August 28, 2022"}},"next":{"fields":{"slug":"/Leetcode-100/"}},"previous":{"fields":{"slug":"/http-basic/"}}},{"node":{"id":"3803d626-4eb5-576f-8c11-f1b36bdefd64","excerpt":"시작 읽기 전에 알면 좋은 내용: blocking/non-blocking, synchronous/asynchronous 은 운영체제와 관련된 개념이다 blocking/non-blocking은 I/O와 엮어서 보면 조금 더 이해가 잘되는 듯 하다 synchronous/asynchronous는 I/O와 엮어서 보면 조금 더 헷갈리는 듯 하다. I/O에서는 synchronous + blocking, asynchronous + non-blocking 방식으로 구현되어 있기 때문에 synchronous = blocking, asynchronous = non-blocking으로 생각되어 헷갈리는 것 같다 프로세스는 메모리에 올라가 실행되는 상태에 있는 프로그램이다 프로세스는 싱글 or 멀티 스레드를 가질 수 있다 스레드는 프로세스의 상태 및 스택에 대한 정보를 공유하지 않고 그 외의 메모리에 저장된 프로세스의 정보를 공유한다 프로세스는 스레드에서 작업을 처리한다. 따라서 싱글 스레드인 경우에…","fields":{"slug":"/blocking-nonblocking-synchronous-asynchronous/"},"frontmatter":{"categories":"WIL","title":"blocking/non-blocking, synchronous/asynchronous","date":"August 21, 2022"}},"next":{"fields":{"slug":"/Leetcode-98/"}},"previous":{"fields":{"slug":"/Leetcode-99/"}}},{"node":{"id":"3a123fe1-e591-5027-b40e-fcc22d01d4ae","excerpt":"시작 읽기 전에 알면 좋은 내용: 브라우저나 node.js는 자바스크립트 엔진을 가지고 있어 자바스크립트가 실행될 수 있는 환경 (=environment)을 제공한다 해당 과정은 Chrome의 V8 엔진 기준으로 작성되었다 엔진 마다 해석 과정에서 약간의 차이가 있을 수도 있다 요약 자바스크립트 코드 -> parsing -> AST (자바스크립트 코드를 트리 구조로 변환한 형태) -> interpretation -> 바이트 코드 (AST를 코드형태로 다시 변환함) -> compilation -> 머신 코드 실행 1. Step: parsing parser는 자바스크립트 코드를 한줄씩 읽으며 두가지 작업을 진행한다 첫번째로 lexical 분석을 통해 자바스크립트 코드를 keyword나 단어로 구분해 의미있는 단어형태(=토큰)으로 구분한다 두번째로 sematic 분석을 통해 나열된 토큰들이 문법적으로 문제가 없는지 확인한다 결과물로 아래와 같이 AST(=abstract syntax tr…","fields":{"slug":"/js-engine/"},"frontmatter":{"categories":"WIL","title":"자바스크립트 엔진이 자바스크립트를 해석하는 과정","date":"August 13, 2022"}},"next":{"fields":{"slug":"/Leetcode-278/"}},"previous":{"fields":{"slug":"/Leetcode-22/"}}},{"node":{"id":"8e11d90f-11b8-5e16-bdb8-454b9e0c8f6e","excerpt":"시작 해당 코드의 차이들에 대해 살펴보기 전에 알아야할 내용: 컴퓨터는 1 bit(=binary digit), 즉 2진수 (0,1) 밖에 이해하지 못한다 이때 0은 전기 신호가 없음, 1은 전기 신호가 있음을 의미한다 0과 1은 컴퓨터가 이해하는 알파벳이라고 보면 된다 컴퓨터는 0과 1을 사용해 정보를 저장할 뿐이다. 저장된 정보를 정해둔 약속에 맞게 해석한 것이 언어가 되는 것이다 1. 바이너리 코드와 머신 코드 바이너리 코드나 머신 코드나 0과 1로 나열되어 표현된 정보이다. (예: 00011000 11011111) 차이는 머신 코드는 머신이 이해할 수 있는 언어이고 바이너리 코드는 그냥 일반적인 정보이다. 2. 바이너리 코드 = 머신 코드? 관점에 따라 바이너리 코드 = 머신 코드가 성립할 수 있지만 약간의 차이가 있다. 컴퓨터에 저장되어 있는 모든 정보는 바이너리 코드이다. 바이너리 코드를 특정한 문법에 따라 해석해 컴퓨터를 조작할 수 있는 것이 머신 코드이다. 컴퓨터는 b…","fields":{"slug":"/code-types/"},"frontmatter":{"categories":"WIL","title":"바이너리 코드, 머신 코드, 바이트 코드, 어셈블리 코드","date":"August 06, 2022"}},"next":{"fields":{"slug":"/Leetcode-189/"}},"previous":{"fields":{"slug":"/Leetcode-278/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/WIL",
    "result": {"pageContext":{"currentCategory":"WIL","categories":["All","WIL","PS","블로그"],"edges":[{"node":{"id":"d368e384-e8c2-5132-9533-e00f1c7aadd1","excerpt":"redux toolkit으로 알아보는 redux 기본 개념 전역 변수와 같은 느낌 redux가 해결하는 문제 props drilling을 통한 불필요한 rerendering과 상태 파악이 힘들다는 문제를 해결하기 위해 만들어짐 구성 요소 저장소 (store) = 여러 state가 객체로 저장되어 있는 느낌 액션 (action) = 저장소의 값을 어떻게 변경할지 정함 리듀서 (reducer) = 액션에 따라 store에 저장된\r\n내용을 변경 (setState 느낌) 프로세스 요약 dispatch 훅을 통해 action을 redux store에 보내게 되면 store에서 받은 action에 알맞는 reducer를 실행해 저장된 내용을 조작한다 리듀서 작성 시 주의 사항 리듀서는 순수함수로 작성 해야함, 즉 외부 내용을 변경하면 안됨 = side effect가 없어야함 따라서 http 요청이나 web storage 접근 등도 불가능함 redux toolkit으로 redux 맛보기 준비사…","fields":{"slug":"/react-basic-part3/"},"frontmatter":{"categories":"WIL","title":"React - basic part 3 (redux)","date":"October 23, 2022"}},"next":{"fields":{"slug":"/pattern-mvc,flux,redux/"}},"previous":null},{"node":{"id":"1883ce52-905e-54fb-9cf4-c5a9a868fe35","excerpt":"MVC Model 실제 데이터와 관련된 로직을 처리한다 결과를 Controller로 보낸다 View Model에서 처리된 결과를 Controller로 부터 받아 보여준다 Controller Model에 어떤 처리를 해야되는지 알려준다 Model에서 처리된 결과를 View로 보낸다 예 일반적: View에서 이벤트가 발생하고 -> Controller에서 이벤트에 해당하는 메소드를 등록하고 -> Model에서 해당 메소드를 수행 후 결과를 Controller로 전달하고 Controller가 해당 결과를 View로 보낸다 pure MVC 패턴은 위에서처럼 단방향이지만 애플리케이션이 커지면서 model이 view에게 view가 model에게 영향을 줄 수 있는 양방향 패턴으로 변모할 수 있다고 한다 Flux MVC가 가지는 Model과 View가 서로에게 데이터를 전달할 수 있는 양방향 데이터 바인딩 문제를 해결하기 위해 만든 패턴 양방향 데이터 바인딩 문제는 Model이 View에 Vie…","fields":{"slug":"/pattern-mvc,flux,redux/"},"frontmatter":{"categories":"WIL","title":"Pattern - MVC, Flux, Redux","date":"October 23, 2022"}},"next":{"fields":{"slug":"/react-basic-part2/"}},"previous":{"fields":{"slug":"/react-basic-part3/"}}},{"node":{"id":"e9a93ac3-5602-59a8-840d-a482e3e5d6c8","excerpt":"리스트와 key 반복되는 컴포넌트가 있다면 map 함수를 사용해 렌더링하는 것이 효율적 key 연속적으로 setState를 호출하면 batch로 묶어서 처리가됨 반복된 컴포넌트가 있을때 key는 어떤 컴포넌트에서 값이 바뀌었는지 파악하는데 도움이됨 key로 고유한 문자열을 사용하는 것이 좋음 -> 그렇지 않으면 해당 리스트의 내용이 변경 됐을때 꼬여서 이상한 위치의 내용이 변경 될 수 있음\r\n따라서 항목의 순서가 바뀔 수 있는 경우 key에 인덱스 값을사용하면 오히려 성능 저하가 발생하거나 state 관련 문제가 발생할 수 있음 key는 형제 관계에서만 고유하면된다 key는 props로 전달되지 않음 함수 컴포넌트에서 이벤트 처리 camelCase 사용 false를 반환하는 것으로 기본 동작 방지 불가, preventDefault 필요 합성 이벤트란? addEventListener 필요없고 컴포넌트에 onClick 이렇게 한 후 콜백함수 등록하면됨 event bubbling 되는 …","fields":{"slug":"/react-basic-part2/"},"frontmatter":{"categories":"WIL","title":"React - basic part 2","date":"October 16, 2022"}},"next":{"fields":{"slug":"/pattern-observer/"}},"previous":{"fields":{"slug":"/pattern-mvc,flux,redux/"}}},{"node":{"id":"5c922eff-ccab-5a2a-bdbb-10b8edaf3cd9","excerpt":"요약 상태 변경을 실시간으로 알릴 수 있는 패턴 Observer 패턴이란 subject (관찰 대상), observer (관찰자)가 존재 관찰대상의 상태가 변경 된 경우 관찰자의 메소드를 호출 함으로써 상태 변경을 알려주는 패턴 로직 observer가 subject에 observer 리스트에 상태 변경 시 실행될 메소드를 등록한다 (observer 자체를 등록한 후 notify 시 해당 observer의 특정한 함수를 실행해도 된다) subject에서 상태가 변경된 후 observer 리스트에 등록된 모든 observer의 메소드를 호출해 상태 변경을 알린다 예시 끝 옵저버 패턴을 응용한 패턴으로 pub/sub 패턴이 있는데 이 부분은 나중에 알아봐야겠다 😊 요약 Observer 패턴이란 로직 예시","fields":{"slug":"/pattern-observer/"},"frontmatter":{"categories":"WIL","title":"Pattern - Observer","date":"October 16, 2022"}},"next":{"fields":{"slug":"/css-bem/"}},"previous":{"fields":{"slug":"/react-basic-part2/"}}},{"node":{"id":"fd530d3d-23dc-5ffa-b65e-6f82056a678b","excerpt":"요약 css 클래스 이름 짓는 방법론 특징 css 명시도 (specificiy)를 높여서 요소에 적용되는 스타일이 충돌하지 않도록 하는 css 아이디와 클래스를 naming하는 방법론이다 기본적으로 아이디는 사용하지 않고 클래스만 사용함 OOCSS, Atomic 등 다른 naming 방법론도 있는데 BEM이 그나마 복잡하지 않음 클래스를 Block(독립 적인 요소), Element(block을 구성하는 단위), Modifier로 구분함 일반적으로 적는 클래스 이름은 block element인 경우 block__element modifier인 경우 block__element—modifier 예. .header => block .header__navigation => element .header__navigation—navi-text => modifier 장,단점 장점: 모듈화 (클래스에 적용되는 css가 서로에게 영향을 주지 않음): block style이 다른 element 스타일…","fields":{"slug":"/css-bem/"},"frontmatter":{"categories":"WIL","title":"CSS - BEM","date":"October 09, 2022"}},"next":{"fields":{"slug":"/react-basic-part1/"}},"previous":{"fields":{"slug":"/pattern-observer/"}}},{"node":{"id":"612bff7e-2d74-572d-adc3-d494d95b63ec","excerpt":"리액트에 대한 이해 리액트 라이브러리는 왜 사용하는 걸까? 라이브러리 선택에는 여러 가지 기준이 존재한다 현재 문제에 가장 적합한 기준을 선택해야한다 예를들어 공통적인 기준으로는 많은 사용자 수 => 대형 커뮤니티 => 낮은 버그 발생률 => 높은 새로운 기능 업데이트 수 가 있다 다른 이유로는 성능 / 속도 / 가독성 등을 이유로 들 수 있다 JSX (Javascript XML) Javascript에 XML을 추가한 확장한 문법이다   JSX는 공식적인 자바스크립트 문법이 아니라 바벨을 사용하여 일반 자바스크립트 형태의 코드로 transpiling 해주어야 한다 html 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙 사용 태그 content가 비어 있으면 /> 닫는 태그를 사용해야함 조건부 렌더링 return 문 내에서 if else 문을 사용하려면 삼항 연산자만 가능함 ({condition} ? {result1} : {result2}) if문 은 && 논리 연산자로…","fields":{"slug":"/react-basic-part1/"},"frontmatter":{"categories":"WIL","title":"React - basic part 1","date":"October 09, 2022"}},"next":{"fields":{"slug":"/Browser-Event-delegation/"}},"previous":{"fields":{"slug":"/css-bem/"}}},{"node":{"id":"0f3863c5-c43f-562b-8c3b-c961539d4110","excerpt":"시작 읽기 전에 알면 좋은 내용: event delegation = 이벤트를 처리하는 패턴 요약 bubbling을 이용한 개념 capturing_bubbling Event delegation 보통 공통으로 처리 될 수 있는 이벤트를 묶어서 처리할때 사용됨, e.g. 이벤트 bubbling 개념을 사용해 각각 child element에 eventlistener를 등록하지 않고 부모 element에만 eventlistener를 등록해 id나 class 등으로 child element를 구분하는 방법이 있음 event delegation을 응용하면 document 객체 (DOM 트리 최상위 노드)에 eventlistener를 등록하고 data property로 element를 구분해 element의 behaviour를 선언적으로 처리 하는 behaviour pattern도 사용 가능함 끝 😊 요약 Event delegation","fields":{"slug":"/Browser-Event-delegation/"},"frontmatter":{"categories":"WIL","title":"Browser - Event delegation","date":"October 01, 2022"}},"next":{"fields":{"slug":"/js-infiniteScroll_pagination_modalPopup/"}},"previous":{"fields":{"slug":"/react-basic-part1/"}}},{"node":{"id":"8038f920-76bc-50f3-b08f-984cd1be329e","excerpt":"시작 infinite scroll 임시로 json 데이터를 가져와야되는 경우 https://jsonplaceholder.typicode.com/posts 사이트 사용하면 유용함 스크롤 맨위 위치 + 클라이언트에게 보여지는 높이가 스크롤을 내린 값보다 커지는 경우 새로운 데이터를 불러오면됨 pagination 페이지네이션 이론 총 페이지 개수 계산 (totalCount / limit) 현재 페이지의 그룹 계산 (currentPage / pageCount) 현재 페이지 그룹의 첫번째/마지막 숫자 구하기 (마지막 숫자 = pageGroup * pagecount, 첫번째 숫자 = 마지막 숫자 (pagecount - 1) 현재 페이지 이전 숫자 계산 (첫번째 숫자 - 1) 현재 페이지 다음 숫자 계산 (마지막 숫자 + 1) 첫번째 숫자가 0이 아닌 경우 prev 버튼이 보이고, 마지막 숫자가 총 페이지 개수 보다 작은 경우 next 버튼이 보이도록 button 요소를 추가하면 된다. 그리고…","fields":{"slug":"/js-infiniteScroll_pagination_modalPopup/"},"frontmatter":{"categories":"WIL","title":"js project - infinite scroll & pagination & modal popup","date":"October 01, 2022"}},"next":{"fields":{"slug":"/Browser-Bubbling-and-capturing/"}},"previous":{"fields":{"slug":"/Browser-Event-delegation/"}}},{"node":{"id":"387dc0b1-9e79-5fd8-902d-62122370f399","excerpt":"시작 읽기 전에 알면 좋은 내용: event.preventDefault는 브라우저가 해당 이벤트에서 행하는 기본 동작을 차단하는 함수이다 event.stopPropagation으로 이벤트가 더이상 이동되지 않게 차단 할 수 있다 event.stopImmediatePropation으로 이벤트가 동일한 depth 의 다른 callback handler도 실행하지 않게 차단할 수 있다 요약 Capturing, Bubbling은 이벤트가 이동하는 방향과 관련된 것임 Capturing = 부모에서 자식 요소로 이벤트가 이동 Bubbling = 자식에서 부모 요소로 이벤트가 이동 capturing_bubbling Capturing html을 트리 구조로 봤을때 capturing은 depth 0 -> depth n 으로 이벤트가 이동 되는 방식 Bubbling bubbling은 depth n -> depth 0 으로 이벤트가 이동 되는 방식 팁 addEventlistener(event, cal…","fields":{"slug":"/Browser-Bubbling-and-capturing/"},"frontmatter":{"categories":"WIL","title":"Browser - Bubbling & Capturing","date":"September 24, 2022"}},"next":{"fields":{"slug":"/js-Text-Editor_Todo-list/"}},"previous":{"fields":{"slug":"/js-infiniteScroll_pagination_modalPopup/"}}},{"node":{"id":"afd47103-62f2-5970-9fa4-8999918df179","excerpt":"시작 Text Editor 기본 로직 텍스트에 style을 바꿀 수 있는 버튼들을 생성하고 각 버튼을 클릭시 이벤트를 발생 + execCommand라는 문서 편집 관련 함수를 사용해 텍스트 에디터를 구현 (현재는 deprecated된 함수) toggle <html요소>.classList.toggle을 통해 class를 넣었다 뺏다 할 수 있음 preventDefault preventDefault 함수를 사용해 html 요소에 기본적으로 동작하는 동작을 취소 시킬 수 있다 innerText, innerHTML, textContent innerText는 html 요소에서 마크업이 적용된 텍스트 내용을 가져 오고, innerHTML은 html 요소에서 텍스트 + html 태그 까지 같이 가져온다, textContent는 마크업이 적용되지 않은 텍스트 내용을 가져와 성능적으로 innerText보다 좋다고 한다 Todo List 기본 로직 DOM 트리가 로딩이 완료 된 후 Todo 리스트를…","fields":{"slug":"/js-Text-Editor_Todo-list/"},"frontmatter":{"categories":"WIL","title":"js project - Text Editor & Todo List","date":"September 24, 2022"}},"next":{"fields":{"slug":"/CSS-BFC(block-formatting-context)/"}},"previous":{"fields":{"slug":"/Browser-Bubbling-and-capturing/"}}},{"node":{"id":"96586c9f-755e-5a23-913a-c88b8d0b2026","excerpt":"시작 읽기 전에 알면 좋은 내용: 블록 요소들은 위에서 아래로 배치되고 inline은 왼쪽에서 오른쪽으로 배치된다. 이러한 동작을 normal flow라고 한다 block_inline block formatting context 에서는 자식 요소들이 normal flow 형식으로 배치된다 html 태그는 가장 처음으로 생성되는 block formatting context이다 요약 block formatting context는 layout에 영향을 주는 성질을 가지고 있지만 보통 float 요소의 위치를 잡을때나 margin collapsing을 방지할때 사용한다고 한다 Contain internal floats 자식 요소 중 float 요소가 있을때 해당 요소를 다른 자식 요소의 height와 동일하게 맞출때 (float 자식 요소가 있을때 동일한 block formatting context에 자식 요소들을 넣을때) bfc1; Exclude external floats 형제 요소 …","fields":{"slug":"/CSS-BFC(block-formatting-context)/"},"frontmatter":{"categories":"WIL","title":"CSS - BFC(Block formatting context)","date":"September 18, 2022"}},"next":{"fields":{"slug":"/js-BrickBreak/"}},"previous":{"fields":{"slug":"/js-Text-Editor_Todo-list/"}}},{"node":{"id":"b1239bf4-21f3-522b-859f-c9b2d54f0032","excerpt":"시작 기본 로직 canvas를 사용해 brick, ball, paddle을 도형으로 그려준다 requestAnimationFrame 함수를 사용해 update와 draw함수를 무한하게 반복적으로 실행하도록 한다 BrickBreak 클래스의 인스턴스를 생성해 init 함수로 게임을 실행한다 requestAnimationFrame 장점: tab이 비활성화 되면 중지, 60프레임으로 동작, 브라우저가 프레임 생성 시간에 맞춰서 애니메이션 코드를 실행 시켜 애니메이션이 부드럽게 동작함 접근성과 관련해 100% 커버리지가 아니라 polyfill 사용하는 것을 추천 (https://gist.github.com/paulirish/1579671) canvas beginPath = 선을 그릴때 시작하는 함수 closePath = 선을 그릴때닫아서 시작점과 잇는 함수 추가한 내용 fontFamily의 크기를 일일히 입력 해주어야하고 canvas에서 한번에 바꾸는 것이 안되어 font의 값들을 배열로…","fields":{"slug":"/js-BrickBreak/"},"frontmatter":{"categories":"WIL","title":"js project - brick break","date":"September 18, 2022"}},"next":{"fields":{"slug":"/Functional Programming-immutability/"}},"previous":{"fields":{"slug":"/CSS-BFC(block-formatting-context)/"}}},{"node":{"id":"19e72d69-d575-50b1-9e14-cd6f7f9311dc","excerpt":"시작 읽기 전에 알면 좋은 내용: immutability는 함수형 프로그래밍의 핵심 개념중 하나로 pure function이 가지고 있는 특징 중 하나이다 side effect란 local environment 가 아닌 다른 environment의 vaiable의 상태(값)를 변경 하는 것을 말한다. 예를 들어 change라는 함수가 global variable a의 값을 변경한다면 side effect가 발생한 것이다 immutability개념을 사용하면 side effect를 방지할 수 있다 요약 immutability란 객체가 생성된 이 후 해당 객체의 상태를 변경할 수 없다는 것을 의미한다. 조금 더 구체적으로 말하자면 메모리의 특정한 주소에 할당된 객체 값이 변경되면 안된다는 것이다 간단하게 말하면 immutable은 메모리 주소에 저장된 내용을 변경할 수 없고 mutable은 메모리 주소에 저장된 내용을 변경할 수 있다는 개념이다 immutable value immuta…","fields":{"slug":"/Functional Programming-immutability/"},"frontmatter":{"categories":"WIL","title":"Functional Programming - immutability","date":"September 10, 2022"}},"next":{"fields":{"slug":"/js-progress bar/"}},"previous":{"fields":{"slug":"/js-BrickBreak/"}}},{"node":{"id":"4ac872e4-cd16-5f47-84f8-62cad4898a7d","excerpt":"시작 정리 박스 모델 기준으로 자바스크립트에서 얻어올 수 있는 값 해당 박스의 border 바깥 쪽은 offsetTop, offsetLeft border 사이는 clientTop, clientLeft 안에 content는 clientWidth, clientHeight border와 content를 합한 것은 offsetWidth, offsetHeight 보여지는 박스가 아닌 content의 전체 길이는 scrollHeight 현재 스크롤바의 위치는 scrollTop values throttle & debounce 이벤트나 요청의 처리 횟수를 컨트롤할때 사용 되는 개념이다 요 사이트에서 마우스 이동 이벤트를 사용한 throttle, debounce 타임 라인을 보면 이해하는데 약간 도움이 되는 것 같다 debounce 들어온 동일한 요청을 하나로 모은 후 마지막 요청만 특정 시간이 지나고나면 실행한다. 여러 요청이 발생 하는데 요청이 다 끝나고 난 후 특정 시간이 지나고 처리할때 사…","fields":{"slug":"/js-progress bar/"},"frontmatter":{"categories":"WIL","title":"js project - progress bar","date":"September 10, 2022"}},"next":{"fields":{"slug":"/Leetcode-114/"}},"previous":{"fields":{"slug":"/Functional Programming-immutability/"}}},{"node":{"id":"366813c1-f81e-5a5d-a6e3-614d868abea6","excerpt":"시작 읽기 전에 알면 좋은 내용: 클라이언트 서버 모델이란? 클라이언트 서버 모델은 서버가 데이터를 가지고 있고 클라이언트에서 데이터를 요청하면 서버에서 데이터를 넘겨 주는 방식의 모델이다 실제로는 통신할때 클라이언트와 서버 사이에 라우터, 모델과 같은 여러 컴퓨터들이 있지만 요런 것들은 network, transport layer에서 처리되고 HTTP는 application layer protocol이기 때문에 서버, 클라이언트 사이의 request와 response에 대해서만 알면된다 server-client 프로토콜이란? 프로토콜은 두 컴퓨터가 소통할떄 어떻게 소통할지 정해놓은 규칙이다. 예를들어 데이터를 어떤 형식으로 보낼 것인지 어떤 순서대로 보낼 것인지 등 요약 서버/클라이언트 모델 기반 프로토콜 connectionless & stateless request, response 구조 http request 상태 코드 http 특징 서버/클라이언트 모델 기반 프로토콜 어떤 …","fields":{"slug":"/http-basic/"},"frontmatter":{"categories":"WIL","title":"http basic","date":"September 02, 2022"}},"next":{"fields":{"slug":"/js-single-thread-non-blocking/"}},"previous":{"fields":{"slug":"/Leetcode-116/"}}},{"node":{"id":"4eceb791-fe8e-5cf2-beeb-bc99c2a13646","excerpt":"시작 읽기 전에 알면 좋은 내용: 프로세스는 메모리에 올라가 실행되는 상태에 있는 프로그램이다 blocking/non-blocking은 호출되는 프로세스가 제어권을 호출하자마자 돌려주는지 아니면 할일을 처리하고 돌려주는지에 대한 것이다 요약 javvascript engine는 single threaded이고 javascript runtime은 multi threaded라 non blocking이 가능하다 자바스크립트는 싱글 스레드, non-blocking 언어이다 위 문장의 정확한 뜻은 자바스크립트 엔진이 싱글 스레드, 자바스크립트 런타임이 non-blocking 이기 때문에 자바스크립트는 싱글 스레드 + non-blocking 두 가지 특징을 모두 갖는다는 의미이다  자바스크립트 엔진 자바스크립트 엔진은 1개의 call stack을 가지고 있기 때문에 한번에 하나의 작업만 처리 가능하다 (=싱글 스레드) 자바스크립트 런타임 자바스크립트 런타임은 실제로 자바스크립트가 실행되는 환경…","fields":{"slug":"/js-single-thread-non-blocking/"},"frontmatter":{"categories":"WIL","title":"javascript - single thread + non-blocking","date":"August 28, 2022"}},"next":{"fields":{"slug":"/Leetcode-100/"}},"previous":{"fields":{"slug":"/http-basic/"}}},{"node":{"id":"3803d626-4eb5-576f-8c11-f1b36bdefd64","excerpt":"시작 읽기 전에 알면 좋은 내용: blocking/non-blocking, synchronous/asynchronous 은 운영체제와 관련된 개념이다 blocking/non-blocking은 I/O와 엮어서 보면 조금 더 이해가 잘되는 듯 하다 synchronous/asynchronous는 I/O와 엮어서 보면 조금 더 헷갈리는 듯 하다. I/O에서는 synchronous + blocking, asynchronous + non-blocking 방식으로 구현되어 있기 때문에 synchronous = blocking, asynchronous = non-blocking으로 생각되어 헷갈리는 것 같다 프로세스는 메모리에 올라가 실행되는 상태에 있는 프로그램이다 프로세스는 싱글 or 멀티 스레드를 가질 수 있다 스레드는 프로세스의 상태 및 스택에 대한 정보를 공유하지 않고 그 외의 메모리에 저장된 프로세스의 정보를 공유한다 프로세스는 스레드에서 작업을 처리한다. 따라서 싱글 스레드인 경우에…","fields":{"slug":"/blocking-nonblocking-synchronous-asynchronous/"},"frontmatter":{"categories":"WIL","title":"blocking/non-blocking, synchronous/asynchronous","date":"August 21, 2022"}},"next":{"fields":{"slug":"/Leetcode-98/"}},"previous":{"fields":{"slug":"/Leetcode-99/"}}},{"node":{"id":"3a123fe1-e591-5027-b40e-fcc22d01d4ae","excerpt":"시작 읽기 전에 알면 좋은 내용: 브라우저나 node.js는 자바스크립트 엔진을 가지고 있어 자바스크립트가 실행될 수 있는 환경 (=environment)을 제공한다 해당 과정은 Chrome의 V8 엔진 기준으로 작성되었다 엔진 마다 해석 과정에서 약간의 차이가 있을 수도 있다 요약 자바스크립트 코드 -> parsing -> AST (자바스크립트 코드를 트리 구조로 변환한 형태) -> interpretation -> 바이트 코드 (AST를 코드형태로 다시 변환함) -> compilation -> 머신 코드 실행 1. Step: parsing parser는 자바스크립트 코드를 한줄씩 읽으며 두가지 작업을 진행한다 첫번째로 lexical 분석을 통해 자바스크립트 코드를 keyword나 단어로 구분해 의미있는 단어형태(=토큰)으로 구분한다 두번째로 sematic 분석을 통해 나열된 토큰들이 문법적으로 문제가 없는지 확인한다 결과물로 아래와 같이 AST(=abstract syntax tr…","fields":{"slug":"/js-engine/"},"frontmatter":{"categories":"WIL","title":"자바스크립트 엔진이 자바스크립트를 해석하는 과정","date":"August 13, 2022"}},"next":{"fields":{"slug":"/Leetcode-278/"}},"previous":{"fields":{"slug":"/Leetcode-22/"}}},{"node":{"id":"8e11d90f-11b8-5e16-bdb8-454b9e0c8f6e","excerpt":"시작 해당 코드의 차이들에 대해 살펴보기 전에 알아야할 내용: 컴퓨터는 1 bit(=binary digit), 즉 2진수 (0,1) 밖에 이해하지 못한다 이때 0은 전기 신호가 없음, 1은 전기 신호가 있음을 의미한다 0과 1은 컴퓨터가 이해하는 알파벳이라고 보면 된다 컴퓨터는 0과 1을 사용해 정보를 저장할 뿐이다. 저장된 정보를 정해둔 약속에 맞게 해석한 것이 언어가 되는 것이다 1. 바이너리 코드와 머신 코드 바이너리 코드나 머신 코드나 0과 1로 나열되어 표현된 정보이다. (예: 00011000 11011111) 차이는 머신 코드는 머신이 이해할 수 있는 언어이고 바이너리 코드는 그냥 일반적인 정보이다. 2. 바이너리 코드 = 머신 코드? 관점에 따라 바이너리 코드 = 머신 코드가 성립할 수 있지만 약간의 차이가 있다. 컴퓨터에 저장되어 있는 모든 정보는 바이너리 코드이다. 바이너리 코드를 특정한 문법에 따라 해석해 컴퓨터를 조작할 수 있는 것이 머신 코드이다. 컴퓨터는 b…","fields":{"slug":"/code-types/"},"frontmatter":{"categories":"WIL","title":"바이너리 코드, 머신 코드, 바이트 코드, 어셈블리 코드","date":"August 06, 2022"}},"next":{"fields":{"slug":"/Leetcode-189/"}},"previous":{"fields":{"slug":"/Leetcode-278/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
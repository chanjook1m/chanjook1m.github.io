{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"fe713b15-1b8a-5776-b086-2eae7f7007ef","excerpt":"문제 링크 https://leetcode.com/problems/diameter-of-binary-tree/ 조건 The number of nodes in the tree is in the range [1, 10^4]. -100 <= Node.val <= 100 입력값 root = binary tree의 루트 노드 출력값 트리의 diameter = 두 node 사이의 가장 긴 거리 풀이과정 depth 값이 가장 큰 왼쪽, 오른쪽 child의 거리가 가장 큰 것이 diameter이다 dfs 방식으로 왼쪽, 오른쪽 child를 traverse 하면서 가장 큰 depth 값을 가진 왼쪽, 오른쪽 child를 찾는다 가장 큰 depth 값을 가진 왼쪽, 오른쪽 child의 depth를 합한 값이 현재 계산한 diameter 값보다 크다면 diameter 값을 업데이트 한다 코드 😊 문제 링크 조건 입력값 출력값 풀이과정 코드","fields":{"slug":"/Leetcode-543/"},"frontmatter":{"categories":"PS","title":"Diameter of Binary Tree","date":"August 14, 2022"}},"next":{"fields":{"slug":"/Leetcode-283/"}},"previous":null},{"node":{"id":"a50a6c30-f5d9-5e17-94ea-90b629cff024","excerpt":"문제 링크 https://leetcode.com/problems/move-zeroes/ 조건 1 <= nums.length <= 10^4 -2^31 <= nums[i] <= 2^31 - 1 입력값 nums = 그냥 배열 출력값 없음, nums 배열 요소의 위치들만 바꾸면됨 풀이과정 배열을 돌면서 0인 경우 해당 idx의 값을 삭제 후 배열의 맨 뒤에 0 을 넣어준다 delete로 삭제 하면 삭제된 idx의 값이 undefined로 바뀌기 때문에 배열을 돌면서 undefined인 경우 배열 요소를 삭제 해주었다 참고: 처음에 삭제할때 splice로 삭제한 후 나중에 삭제한 0의 갯수만큼 배열에 0을 추가해주는 방법도 있다 참고: 처음에 삭제할때 splice로 삭제하면서 동시에 0을 추가해 한개의 루프로 해결하려고 해봤는데 index값이 줄어 들기 때문에 삭제 후 index를 1 줄여주고 나니 무한루프에 빠졌었다 코드 😊 문제 링크 조건 입력값 출력값 풀이과정 코드","fields":{"slug":"/Leetcode-283/"},"frontmatter":{"categories":"PS","title":"Move Zeroes","date":"August 14, 2022"}},"next":{"fields":{"slug":"/Leetcode-22/"}},"previous":{"fields":{"slug":"/Leetcode-543/"}}},{"node":{"id":"5732c95a-063d-5c43-93f4-37a7dc450127","excerpt":"문제 링크 https://leetcode.com/problems/generate-parentheses/ 조건 1 <= n <= 8 입력값 n = 괄호의 pair 갯수 출력값 괄호짝이 맞는 combination을 배열에 넣어 출력 풀이과정 backtracking을 사용해 combination을 만든다 combination의 길이가 2*n인 경우 pair가 꽉 차있기 때문에 result에 결과를 넣어준다 왼쪽 괄호가 아직 n 개 만큼 없는 경우 왼쪽 괄호를 넣어준다 오른쪽 괄호가 아직 왼쪽 괄호의 갯수만큼 없다면 오른쪽 괄호를 넣어준다 이렇게 하면 괄호짝이 맞는 well-formed combination을 완성할 수 있다 코드 😊 문제 링크 조건 입력값 출력값 풀이과정 코드","fields":{"slug":"/Leetcode-22/"},"frontmatter":{"categories":"PS","title":"Generate Parentheses","date":"August 14, 2022"}},"next":{"fields":{"slug":"/js-engine/"}},"previous":{"fields":{"slug":"/Leetcode-283/"}}},{"node":{"id":"3a123fe1-e591-5027-b40e-fcc22d01d4ae","excerpt":"시작 읽기 전에 알면 좋은 내용: 브라우저나 node.js는 자바스크립트 엔진을 가지고 있어 자바스크립트가 실행될 수 있는 환경 (=environment)을 제공한다 해당 과정은 Chrome의 V8 엔진 기준으로 작성되었다 엔진 마다 해석 과정에서 약간의 차이가 있을 수도 있다 요약 자바스크립트 코드 -> parsing -> AST (자바스크립트 코드를 트리 구조로 변환한 형태) -> interpretation -> 바이트 코드 (AST를 코드형태로 다시 변환함) -> compilation -> 머신 코드 실행 1. Step: parsing parser는 자바스크립트 코드를 한줄씩 읽으며 두가지 작업을 진행한다 첫번째로 lexical 분석을 통해 자바스크립트 코드를 keyword나 단어로 구분해 의미있는 단어형태(=토큰)으로 구분한다 두번째로 sematic 분석을 통해 나열된 토큰들이 문법적으로 문제가 없는지 확인한다 결과물로 아래와 같이 AST(=abstract syntax tr…","fields":{"slug":"/js-engine/"},"frontmatter":{"categories":"WIL","title":"자바스크립트 엔진이 자바스크립트를 해석하는 과정","date":"August 13, 2022"}},"next":{"fields":{"slug":"/Leetcode-278/"}},"previous":{"fields":{"slug":"/Leetcode-22/"}}},{"node":{"id":"2a9fad7e-6acd-569a-a7df-c7f883232062","excerpt":"문제 링크 https://leetcode.com/problems/first-bad-version/ 조건 1 <= bad <= n <= 2^31 - 1 bad version 이 후 version 들은 모두 bad version임 입력값 isBadVersion = 해당 숫자가 BadVersion인지 확인하는 함수 (true/false return함) - leetcode에서 제공되는 API n = 버전의 갯수 [1,…,n] 로 사용된다고 생각하면됨 출력값 버전 중에서 가장 작은 수를 가진 bad version 값 풀이과정 일반 루프를 사용해봤는데 time limit exceeded 에러 발생 (n의 값이 20억이 넘기 떼문) binary search를 사용해 20억번 확인할 것을 9번으로 줄임 현재 위치의 값이 bad version인 경우 이 후 version 들은 모두 bad version 이기 때문에 찾는 범위를 왼쪽으로 이동 현재 위치의 값이 bad version이 아닌 경우 이 …","fields":{"slug":"/Leetcode-278/"},"frontmatter":{"categories":"PS","title":"First Bad Version","date":"August 06, 2022"}},"next":{"fields":{"slug":"/code-types/"}},"previous":{"fields":{"slug":"/js-engine/"}}},{"node":{"id":"8e11d90f-11b8-5e16-bdb8-454b9e0c8f6e","excerpt":"시작 해당 코드의 차이들에 대해 살펴보기 전에 알아야할 내용: 컴퓨터는 1 bit(=binary digit), 즉 2진수 (0,1) 밖에 이해하지 못한다 이때 0은 전기 신호가 없음, 1은 전기 신호가 있음을 의미한다 0과 1은 컴퓨터가 이해하는 알파벳이라고 보면 된다 컴퓨터는 0과 1을 사용해 정보를 저장할 뿐이다. 저장된 정보를 정해둔 약속에 맞게 해석한 것이 언어가 되는 것이다 1. 바이너리 코드와 머신 코드 바이너리 코드나 머신 코드나 0과 1로 나열되어 표현된 정보이다. (예: 00011000 11011111) 차이는 머신 코드는 머신이 이해할 수 있는 언어이고 바이너리 코드는 그냥 일반적인 정보이다. 2. 바이너리 코드 = 머신 코드? 관점에 따라 바이너리 코드 = 머신 코드가 성립할 수 있지만 약간의 차이가 있다. 컴퓨터에 저장되어 있는 모든 정보는 바이너리 코드이다. 바이너리 코드를 특정한 문법에 따라 해석해 컴퓨터를 조작할 수 있는 것이 머신 코드이다. 컴퓨터는 b…","fields":{"slug":"/code-types/"},"frontmatter":{"categories":"WIL","title":"바이너리 코드, 머신 코드, 바이트 코드, 어셈블리 코드","date":"August 06, 2022"}},"next":{"fields":{"slug":"/Leetcode-189/"}},"previous":{"fields":{"slug":"/Leetcode-278/"}}},{"node":{"id":"a3736717-3bbc-5432-a3aa-ec392cb1babc","excerpt":"문제 링크 https://leetcode.com/problems/rotate-array/ 조건 1 <= nums.length <= 10^5 -2^31 <= nums[i] <= 2^31 - 1 0 <= k <= 10^5 입력값 nums = 그냥 배열 k = 회전할 횟 수 출력값 없음, nums 배열 요소의 위치들만 바꾸면됨 풀이과정 처음에 nums.length <= 10^5 조건을 보지 않고 2중 루프로 구현해 time limit exceeded 에러가 발생했다 (다음부터는 조건 부분을 먼저 확인하자) 시간을 줄이기 위해 nums 배열을 복사한 후 해당 배열의 요소 값을 가져오는 방법을 사용했다 k를 nums의 길이와 나눈 나머지 값을 사용해 k가 nums.length보다 클때 제자리로 rotate 되는 부분을 제거한다 배열 뒷 요소부터 바꾸는 전략을 취했는데 어차피 복사한 배열에서 값을 가져오는 거라 순서는 상관 없었을듯 하다 아무튼 뒷 요소부터 i-k로 rotate 후 위치될 값…","fields":{"slug":"/Leetcode-189/"},"frontmatter":{"categories":"PS","title":"Rotate Array","date":"August 06, 2022"}},"next":{"fields":{"slug":"/Leetcode-35/"}},"previous":{"fields":{"slug":"/code-types/"}}},{"node":{"id":"c97f8155-32f3-53ab-9c67-33f09dfbe288","excerpt":"문제 링크 https://leetcode.com/problems/search-insert-position/ 조건 1 <= nums.length <= 10^4 -10^4 <= nums[i] <= 10^4 nums는 오름차순으로 정렬되어 있음 -10^4 <= target <= 10^4 O(log n) 알고리즘 작성 입력값 nums = 오름차 순으로 정렬된 배열 target = 찾는 값 출력값 찾는 값이 있으면 해당 값의 index, 없으면 target이 오름차순으로 정렬했을때 들어가야할 index 위치 값 풀이과정 Binary search를 사용해 target의 index를 찾음 target이 있으면 index return 없는 경우 for 문을 돌면서 target이 들어갈만한 위치를 찾는다 코드 😊 문제 링크 조건 입력값 출력값 풀이과정 코드","fields":{"slug":"/Leetcode-35/"},"frontmatter":{"categories":"PS","title":"Search Insert Position","date":"August 06, 2022"}},"next":{"fields":{"slug":"/2022-kakao-blind-5/"}},"previous":{"fields":{"slug":"/Leetcode-189/"}}},{"node":{"id":"7ed55730-568d-5804-95b0-47f47ffde2ce","excerpt":"문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92343 조건 루트 노드에는 항상 양이 있음 (answer 최소값 1) 늑대의 수가 양의 수보다 같거나 크면 모든 양을 잡아먹음 입력값 info = 각 노드에 양 (0) 이 있는지 늑대 (1) 가 있는지에 대한 정보 (배열) edges = 각 노드들의 연결 관계를 저장하고 있음 (2차원 배열) ([0,1] = 1은 0의 child 노드) 출력값 모을 수 있는 최대 양의 개수 풀이과정 DFS를 사용해 모든 경우의 수를 확인 한다 주어진 노드들의 연결 관계를 2차원 배열을 사용해 그래프 형태로 저장한다 각 노드들을 traverse 하면서 양의 수와 늑대의 수를 더한다 늑대의 수가 양의 수보다 같거나 크면 return 늑대의 수가 양의 수보다 작으면 최대 양의 수를 업데이트 한 후 현재 노드의 child 들을 다음에 확인할 노드 배열에 push 하고 현재 노드를 해당 배열에서 삭제한다…","fields":{"slug":"/2022-kakao-blind-5/"},"frontmatter":{"categories":"PS","title":"양과 늑대","date":"March 30, 2022"}},"next":{"fields":{"slug":"/2022-kakao-blind-4/"}},"previous":{"fields":{"slug":"/Leetcode-35/"}}},{"node":{"id":"ba5d8b3c-8cf5-52b6-a4d0-06e3d3672357","excerpt":"문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92342 조건 k점 과녁에 한발이라도 더 많은 화살을 맞힌 선수가 k점을 가져감 k점 과녁에 아무도 화살을 맞히지 못하면 어느 누구도 k점을 가져가지 않음 입력값 info = 어피치가 맞힌 과녁 점수의 개수 (index 0 = 10점, … , index 10 = 0점) (배열) n = 라이언이 쏠 수 있는 화살의 개수 출력값 어떤 과녁 점수에 n 발의 화살을 맞춰야 하는지 10점부터 0점 까지 순서대로 배열에 담아 출력 (index 0 = 10점, … , index 10 = 0점) 모든 경우의 수를 확인 한 후에도 라이언과 어피치의 점수차가 같거나 어피치가 높은 경우 [-1] return 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 풀이과정 낮은 점수를 더 맞힌 경우를 찾아야 하기 때문에 index …","fields":{"slug":"/2022-kakao-blind-4/"},"frontmatter":{"categories":"PS","title":"양궁대회","date":"March 28, 2022"}},"next":{"fields":{"slug":"/2022-kakao-blind-3/"}},"previous":{"fields":{"slug":"/2022-kakao-blind-5/"}}},{"node":{"id":"34af4876-227f-56ce-9ab8-fb14f12f4ce3","excerpt":"문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92341 조건 차량에 입차 내역만 있고 출차 내역이 없으면 23:59에 출차된 것 누적 주차 시간이 기본 시간 이하인 경우 -> 기본 요금 누적 주차 시간이 기본 시간을 초과한 경우 -> (기본요금 + 올림(누적시간 - 기본시간) / 단위시간) x 단위 요금) 입력값 fees = 주차 요금 항목 (배열) records = 자동차 입/출력 내역 (배열) 출력값 자동차 청구 주차 요금 (배열) 차량 번호가 작은 자동차 순서대로 담아야됨 풀이과정 Hashmap을 사용해 각 자동차에 대해 입차시간, 총 주차 시간을 저장 출차 내역이 없는 자동차들의 총 주차 시간을 계산하기 위해 입차, 출차를 동기화 하는 배열 사용 IN인 경우 입차시간을 업데이트 OUT인 경우 출차시간 - 입차시간을 계산해 총 주차 시간을 업데이트 출차 내역이 없는 자동차들의 총 주차 시간을 업데이트 모든 자동차의 총 …","fields":{"slug":"/2022-kakao-blind-3/"},"frontmatter":{"categories":"PS","title":"주차 요금 계산","date":"March 26, 2022"}},"next":{"fields":{"slug":"/2022-kakao-blind-1/"}},"previous":{"fields":{"slug":"/2022-kakao-blind-4/"}}},{"node":{"id":"d17c447f-4292-56c3-9159-0460fda16e39","excerpt":"문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92334 조건 한번에 한 유저를 신고 가능 → A유저가 B,C 유저를 동시에 신고할 수 없음 (신고한 내용은 ‘userA userB’ 형태를 가짐) 동일한 유저 신고 횟수는 1회로 처리 → A유저가 B유저를 두번 이상 신고해도 1번 신고한걸로 처리됨 신고 횟수 제한 없음 k번 이상 신고된 유저는 정지 → k가 2이고 A유저가 C유저를 신고했고 B유저도 C유저를 신고하면 C유저는 정지됨 신고된 모든 내용을 취합 후 신고한 유저들에게 정지 사실 이메일 보내짐 자기 자신을 신고할 수 없음 입력값 id_list = 모든 유저 아이디 목록 (배열) report = 유저가 신고한 내용 목록 (배열) 출력값 각 유저가 받은 정지 사실 이메일 갯수 목록 (배열) id_list에 담긴 id 순서대로 담아야됨 풀이과정 key, value 형태로 데이터를 저장하는 HashMap 사용 key에는 유저…","fields":{"slug":"/2022-kakao-blind-1/"},"frontmatter":{"categories":"PS","title":"신고결과받기","date":"March 25, 2022"}},"next":{"fields":{"slug":"/first-post/"}},"previous":{"fields":{"slug":"/2022-kakao-blind-3/"}}},{"node":{"id":"af754185-e14b-56a1-9a59-84f56eed9c25","excerpt":"👋 글쓰기 원칙 이 원칙들을 최대한 지키려고 해보자 기록해야할 & 기록하고 싶은 내용만 기록한다 포스팅 수를 채우기 위한 글은 작성하지 않는다 너무 긴글 (3-5분 이상 읽어야 하는글)은 여러개로 나눠서 올린다 feynman 방법을 사용해 주제를 정한 후 어린아이에게 설명하듯이 적는다 쉬운 언어로 설명하지 못하는 단어는 사용을 자제한다 어떤 내용을 포함하고 포함하지 않는지에 대한 정보를 글 초반에 적는다 😊 👋 글쓰기 원칙","fields":{"slug":"/first-post/"},"frontmatter":{"categories":"블로그","title":"블로그 시작","date":"March 24, 2022"}},"next":null,"previous":{"fields":{"slug":"/2022-kakao-blind-1/"}}}],"categories":["All","PS","WIL","블로그"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}